#ifndef ENGINE_H
#define ENGINE_H

#include <utility>
#include <random>
#include <vector>
#include <queue>
#include "general.h"
#include "region.h"
#include "creature.h"

/// @brief Minium size of a room
#define MIN_ROOM_DIMENSION 2
/// @brief Maximum size of a room
#define MAX_ROOM_DIMENSION 10

/// @brief Probability of attempting to select existing room
#define EXISTING_ROOM_PROB 0.80

/// @brief The radius of the field of view
#define FOV_RADIUS 15

/// @brief Background/foreground struct
struct BaF {
	Background background;
	Foreground foreground;
	CreatureType creatureHere;
	Team creatureTeam;
	ItemType itemHere;
	double HPPerHere;
};

/// @brief Class for the game engine
class Engine {
	private:
		/// @brief Random number engine
		std::mt19937 randomengine;

		/// @brief Distribution for room dimensions
		std::uniform_int_distribution<int> roomdist;

		/// @brief distribution from 0 to 1
		std::uniform_real_distribution<double> probdist;

		/// @brief The player creature
		Creature* player = NULL;

		/// @brief Vector of the creatures
		std::vector<Creature*> creatures;

		/// @brief Vector to hold all regions, to allow deletion
		std::vector<Region*> regions;

		/// @brief Manage the alternate region
		///
		/// @param curregion The current region
		/// @param position The current position
		void manageAltRegion(Region * curregion, const Point& position);

		/// @brief Swap the alternate and active regions
		///
		/// @param creature The creature whose region is being swapped
		void swapRegions(Creature * creature);

		/// @brief Map of visible squares, accessed indirectly by the app
		std::map<Point, Visibility>* visiblelocations = NULL;

		/// @brief Converter between point and actual location
		///
		/// @param point Point
		/// @param relto What point is relative to
		/// @param region The region point is on
		///
		/// @return Pair of Foreground/Background
		BaF relBaF(Point point, const Point & relto, Region * region);

		/// @brief Refresh field of view map
		void refreshFOV();

		/// @brief Get the FOV from and relative to a point
		///
		/// @param point The point (e.g. currentPosition)
		/// @param region The region FOV is working on
		///
		/// @return A new std::map of visibility, relative to point
		std::map<Point, Visibility>* FOV(Point point, Region * region);
		
		/// @brief Populate a new region with creatures
		///
		/// @param region The region
		void PopulateNewRegion(Region * region);

	public:
		/// @brief Constructor
		Engine();
		

		/// @brief Destructor
		~Engine();

		/// @brief get background of point relative to currentPosition
		///
		/// @param point Point relative to currentPosition
		///
		/// @return The background value, if visible
		Background getBackground(Point point);

		/// @brief Get foreground of point relative to currentPosition
		///
		/// @param point Point relative to currentPosition
		///
		/// @return The foreground value, if visible
		Foreground getForeground(Point point);

		/// @brief Get whether or not a creature is seen here
		///
		/// @param point Point
		///
		/// @return True if creature seen here
		bool seeCreatureHere(Point point);

		/// @brief Get the HP fraction here
		///
		/// @param point The position
		///
		/// @return The HP fraction
		double creatureHPPercentHere(Point point);

		/// @brief Move in a direction
		///
		/// @param direction The (8-way) direction to move in
		///
		/// @return Success/fail
		bool Move(Direction direction);

		/// @brief Expose currentPosition
		///
		/// @return currentPosition by value
		inline Point getCurrentPosition() {
			return player->getPosition();
		}

		/// @brief Run astar to find the fastest route between two points
		///
		/// @param start The starting point
		/// @param finish The ending point
		/// @param relativeTo A point to which this is relative to, e.g. currentPosition
		/// @param region The region that the astar is working on
		///
		/// @return A queue of Directions that will lead you to finish from start via the fastest route as generated by astar
		std::queue<Direction> * astar(Point start, Point finish, Point relativeTo, Region * region);

		/// @brief Astar from the POV of the player
		///
		/// @param start Starting location (generally 0,0)
		/// @param finish Finish location
		///
		/// @return Queue of directions
		inline std::queue<Direction> * playerAstar(Point start, Point finish) {
			player->updateFOV(FOV(player->getPosition(), player->getRegion()));
//			return astar(start, finish, player->getPosition(), player->getRegion());
			return player->astar(start, finish);
		}

		/// @brief Expose underForeground
		///
		/// @return Reference to underForeground
		inline Foreground underWitch() {
			return getItemForeground(player->getRegion()->topItem(player->getPosition()));
		}

		/// @brief Get the string of the stuff under the player
		///
		/// @return The string
		inline std::string underItemString() {
			return player->getRegion()->itemHereString(player->getPosition());
		}

		/// @brief Do all the monster's turns
		void doMonsterTurns();

		/// @brief Move a specific monster
		///
		/// @param creature The creature
		/// @param direction The direction
		///
		/// @return Success/fail
		bool monsterMove(Creature * creature, Direction direction);

		void ReportState();

		/// @brief Handle one creature attacking another
		///
		/// @param attacker The attacker
		/// @param defender The defender
		bool handleAttack(Creature * attacker, Creature * defender);

		/// @brief Remove a creature from the game
		///
		/// @param deadded The creature to be removed
		void removeFromGame(Creature * deadded);

		/// @brief Get the player's properties
		///
		/// @return The player properties
		inline const creatureProperties& getPlayerProperties() {
			return player->Properties();
		}

		inline const Inventory& getPlayerInventory() {
			return player->getInventory();
		}

};

#endif
